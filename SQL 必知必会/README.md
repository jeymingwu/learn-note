#  SQL必知必会（第四版）

## 1. SQL

+  数据库： 一个以某种有组织的方式存储的数据集合；
    +  数据库软件：DBMS
    +  表：一种结构化文件，某种特定类型数据的结构化清单；可存储某种特定类型的数据；
    +  模式： 关于数据库和表的布局及特性的信息；
    +  列： 表中的一个字段；
    +  行： 表中的一个记录；
    +  主键： 一列（或一组列），其值能够唯一标识表中每一行；
    +  主键的条件：
        1. 任意两行都不具有相同的主键值；
        2. 每一行都必须有一个主键值（主键列不允许为 NULL 值）；
        3. 主键列中的值不允许修改或更新；
        4. 主键值不能重用（若某行从表中删除，那么它的主键不能赋给以后的新行？）；
    +  多个列作主键，所有列组合必须唯一；
+  SQL ： Structured Query Language
    +  设计目的： 提供一种从数据库中读写数据的简单有效方法；
    +  优点：
        +  SQL 不是特定数据库供应商专有语言；
        +  简单易学；
        +  强有力语言；
        
## 2. 检索数据

+  SELECT 语句
    +  SQL 语句注意：
        +  以分号结束；
        +  不区分大小写；
            +  所有空格被忽略；
        +  检索多个列，列名之间以逗号分隔；
        +  检索所有列：星号（*）通配符；
        +  检索不同的值：DISTINCT 关键字（直接放在列名前面）；
            +  注意： DISTINCT 关键字作用于所有的列；
        +  限制结果：返回第一行或者一定数量的行；
            +  各种数据库实现的方式：
                +  SQL Server \ Access ——> TOP关键字： SELECT TOP 1 name FROM form;
                +  DB2 ： SELECT name FROM form FETCH FIRST 1 ROWS ONLY;
                +  Oracle ——> ROWNUM 行计数器: SELECT name FROM form WHERE ROWNUM <= 1;
                +  MySQL \ MariaDB \ PostgreSQL \ SQLite ——> LIMIT 字句：
                    +  SELECT name FROM form LIMIT 1; // 一条数据（第一条）
                    +  SELECT name FROM form LIMIT 1 OFFSET 5; // 第五行后的一条（第六条）数据；第一个数字是检索的行数，第二个数字是从哪开始
                    +  简化版：LIMIT 5,1; // 逗号之前的值对应 OFFSET，之后对应 LIMIT
        +  使用注释
            +  行内解释：“--”
            +  “#”
            +  "/**/"
        
## 3. 排序检索数据
    
+  ORDER BY 子句（若出现，必然是 SQL 中最后一条语句）
+  多列列排序：简单指定列名，列名之间用逗号隔开；按列名顺序依次排序；
+  按列位置排序
+  指定排序方向：
    +  ASC：升序（默认）（ASCENDING）
    +  DESC：降序（DESCENDING）
    
## 4.  过滤数据

+  WHERE 子句
+  搜索条件（过滤条件）
+  检查单个值： SELECT name FROM from WHERE name = 'tony';
+  不匹配检查:  SELECT name FROM from WHERE name <> 'tony';
+  范围值检查： SELECT name FROM from WHERE name BETWEEN 'tony' AND 'Jenny';
+  空值检查: SELECT name FROM from WHERE name IS NULL;

WHERE  子句操作符  
    
| 操作符 | 说明  |
| :----:   | :----: |
|  = | 等于
| <> | 不等于 | 
| != | 不等于 | 
| < | 小于 | 
| <= | 小于等于 | 
| !< | 不小于 |
|  \> | 大于 |
| >= | 大于等于 | 
| !> | 不大于 | 
| BETWEEN | 在指定的两个值之间 |
| IS NULL | 为 NULL 值 | 
            
## 5.  高级数据过滤：组合 WHERE 子句：

+  操作符：
    +  AND  （优先级高）
    +  OR
    +  IN
        +  优点：
            +  IN 操作符语法更清楚更直观；
            +  求值顺序容易管理；
            +  IN 比 OR 执行上更快
            +  可包含其他 SELECT 语句
    +  NOT （不单独使用）
        
## 6.  用通配符进行过滤

+  LIKE 关键字
    +  搜索模式：由字面值、通配符或两者组合构建的搜索条件；
    +  通配符：用来匹配值的一部分特殊字符；(区分大小写)
        +  百分号（%）通配符：表示任意字符出现任意次数；（Access 需使用'*'）
        +  下划线（_）通配符：只匹配单个字符；（Access 需使用'?'）
        +  方括号（[]）通配符：指定一个字符集，必须匹配指定位置的一个字符；（只支持 Access 和 SQL Server）
+  使用技巧：
    +  不要过度使用；
    +  尽量不要放在搜索模式的开始处；
    +  注意通配符的位置；

## 7. 创建计数字段

+  计算字段：并不实际存在数据库表中，是在运行时 SELECT 语句内创建的；
+  拼接字段：
    +  拼接：将值连接在一起构成单个值；
    +  使用 加号（+）或两个竖杠（||）表示；（MySQL 和 MariaDB 不支持，需使用特殊函数concat）
    +  TRIM 函数
        +  使用 RTRIM() 消除拼接填充的空格；去掉值右边的所有空格；
        +  LTRIM()：去掉字符创左边的空格；
        +  TRIM()：去掉字符串左右两边的空格；
+  使用别名：AS
+  执行算术计算
    +  "+"、"-"、"*"、"/"：加、减、乘、除
        
## 8.  使用函数处理数据

+  函数
    +  提取字符串的组成部分：
        +  Access：MID()
        +  DB2\Oracle\PostgreSQL\SQLite：SUBSTR()
        +  MySQL\SQL Server：SUBSTRING()
    +  数据类型转换：
        +  Access\Oracle：有多个函数，每个类型的转换分别有一个；
        +  BD2\PostfreSQL：CAST()
        +  MariaDB\MySQL\SQL Server：CONVERT()
    +  取当前日期：
        +  Access：NOW()
        +  BD2\PostgreSQL：CURRENT_DATE
        +  MariaDB\MySQL：CURDATE()
        +  Oracle：SYSDATE
        +  SQL Server：GETDATE()
        +  SQLite：DATE()
+  使用函数：
    +  用于处理文本字符串；
    +  用于数值数据上进行算术操作的数值函数；
    +  用于处理日期和时间值并从这些值中提取特定成分的日期和时间函数；
    +  返回 DBMS 整使用的特殊信息的系统函数；

常用的文本处理函数

| 函数 | 说明 | 备注 |
| :---: | :---: | :--- |
| LEFT() | 返回字符串左边的字符 | 或使用子字符串函数 |
| RIGHT() | 返回字符串右边的字符 | 或使用子字符串函数 |
| LTRIM() | 去掉字符串左边的空格 | -|
| RTRIM() | 去掉字符串右边的空格 | -|
| LOWER() | 将字符串转换为小写 | Access 使用 LCASE() |
| UPPER() |  将字符串装换为大写 | Access 使用 UCASE() |
| LENGTH() |  返回字符串的长度 | -|
| SOUNDEX() | 返回字符串的 SOUNDEX 值 | SOUNDEX 是一个将任何文本串装换成其语音表示的字母数字模式的算法 |

数值处理函数

|  函数  |  说明  |
| :---: | :---: |
| ABS() | 返回一个数的绝对值 |
| COS() | 返回一个角度的余弦值 |
| EXP() | 返回一个数的指数值 |
| PI() | 返回圆周率 |
| SIN() | 返回一个角度的正弦值 |
| SQRT() | 返回一个数的平方根 |
| TAN() | 返回一个角度的正切值 |
    
## 9. 汇总数据

+  聚集函数：检索数据，以便分析和报表生成；
+  例子：
    +  确定表中的行数；
    +  获得表中的某行的和；
    +  找出表列的最大值、最小值、平均值等；
+  AVG() : 返回某列的平均值
    +  只用于单个列，若求多个列需使用多个 AVG() 函数；
    +  忽略列值为 NULL 的行；
+  COUNT() : 计数
    +  COUNT(*)：对表中行的数目进行计数；不管表列中包含的是空值还是非空值；
    +  COUNT(column)：对特定列中具有值得行进行计算，忽略 NULL 值；
+  MAX() ：返回列中的最大值
    +  对非数值数据使用 MAX() ：对于文本数据时，返回该列排序后的最后一行；
    +  忽略列值为 NULL 的行；
+  MIN() ：返回列中最小值
    +  对非数值数据使用 MIN() ：对于文本数据时，返回该列排序后的最前一行；
    +  忽略列值为 NULL 的行；
+  SUM()：返回指定列值的总和

SQL 聚集函数  

|  函数  |  说明  |
| :---: | :---: |
|  AVG() | 返回某列的平均值 |
|  COUNT() | 返回某列的行数 |
|  MAX() | 返回某列的最大值 |
|  MIN() | 返回某列的最小值 |
|  SUM() | 返回某列值之和 |
    
## 10. 分组数据

+  创建分组：GROUP BY 子句
+  过滤分组：HAVING 子句
    +  HAVING 与 WHERE 的差别：WHERE 在数据分组前进行过滤，HAVING 在数据分组后进行过滤；
    +  使用 HAVING 时应结合 GROUP BY 子句；
+  GROUP BY 与 ORDER BY
    +  ORDER BY ：对产生的输出排序；任意列都可以使用；不一定需要；
    +  GROUP BY ：对行分组，但输出可能不是分组的顺序；只可能使用选择列或表达式列，而且必须使用每个选择列的表达式；若与聚集函数一起使用列，则必须使用；
+  SELECT 子句顺序：
    +  SELECT：要返回的列或表达式；必须使用；
    +  FROM：从中检索数据的表；仅在从表选择数据时使用；
    +  WHERE：行级过滤；非必须使用；
    +  GROUP BY：分组说明；仅在按组计算聚集时使用；
    +  HAVING：组级过滤；非必须使用；
    +  ORDER BY：输出排序顺序；非必须使用；
        
## 11. 使用子查询

## 12. 联结表

+  联结：SQL 最强大的功能之一；能在数据查询的执行中联结表；
    +  WHERE 子句的重要性：若没有，返回的结果为笛卡尔积；（叉联结）
    +  等值联结-（又称：内联结）
    +  联结的表越多，性能下降越厉害；
+  关系表：将信息分解成多个多个表，一类数据一个表；通过某些共同的值湘湖关联；
    
## 13. 创建高级联结

+  使用表别名；
+  不同类型的联结：
    +  内联结（等值联结）
    +  自联结：联结查询的表示相同的表；
    +  自然联结：特殊的等值联结，把重复的属性列去掉；（与内联结的区别）
    +  外联结：表与表相联结，包含了没有关联行的那些行；
        +  LEFT OUTER JOIN
        +  RIGHT OUTER JOIN
        +  FULL OUTER JOIN
+  带聚集函数的联结
    
## 14. 组合查询

+  UNION 关键字
+  自动去除重复的行；
+  对组合查询结果排序：ORDER BY 子句位于最后一条 SELECT 语句之后； 
+  使用规则：
    +  必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字 UNION 分隔；
    +  UNION 每个查询必须包含相同列、表达式或聚合函数；
    +  列数据类型必须兼容；
        
## 15. 插入数据

+  INSERT INTO table VALUES()
+  方式：
    +  插入完整行；
    +  插入行的一部分；
    +  插入某些查询的结果:INSERT SELECT 
+  从一个表复制到另一个表：SELECT INTO

## 16. 更新和删除数据

+  更新数据：UPDATE table SET …… WHERE ……
+  删除数据：DELETE FROM table WHERE ……
    
## 17. 创建和操纵表

+  创建表：CREATE TABLE table ();
    +  表定义：列名开始，接着数据类型，逗号分隔；
    +  使用 NULL 值：NULL / NOT NULL
    +  指定默认值：DEFAULT 
+  更新表：ALTER TABLE
+  删除表：DROP TABLE
    
## 18. 使用视图

+  视图：虚拟的表；只包含使用时动态检索数据的查询；
+  视图的使用好处：
    +  重用 SQL 语句；
    +  简化复杂的 SQL 操作；
    +  使用表的一部分而不是整个表；
    +  保护数据；
    +  更改数据格式和表示；
+  性能问题：视图不包含数据，每次使用视图时，都必须处理查询执行时需要的所有检索；
+  视图的使用规则和限制：
    +  与表一样，视图命名必须唯一；
    +  视图创建的数量没有限制；
    +  创建视图需有足够的权限；
    +  视图可以嵌套；（可能会严重降低查询的性能）
    +  许多 DBMS 禁止在视图查询中使用 ORDER BY 子句；
    +  某些 DBMS 需要对返回的所有列进行命名；
    +  视图不能索引，也不能有关联的触发器或默认值；
    +  某些 DBMS 把视图作为只读的查询；
+  创建视图：CREATE VIEW viewname AS SELECT …… FROM ……
+  视图重命名：先删除视图，再重新创建；DROP VIEW viewname;
    
## 19. 存储过程

+  定义：为以后使用而保存的一条或多条 SQL 语句；——> 可视为批文件；
+  使用存储过程的好处：简单、安全、高性能；
    +  把处理封装再一个易用单元里，可简化复杂的操作；
    +  由于不需要反复建立一系列处理步骤，防止错误保证了数据的一致性；
    +  简化对变动的管理；
    +  存储过程一编译过的形式存储，所以DBMS 处理命令所需的工作量减少，提高了性能；
    +  储存一些只能用在单个请求中的 SQL 元素和特性，存储过程可以使用他们来编写功能更强更灵活的代码；
+  执行存储过程：EXECUTE
+  创建存储过程
    
## 20. 管理实务处理

+  术语
    +  事务 transaction
    +  回退 rollback
    +  提交 commit
    +  保留点 savepoint
+  处理事务
    +  SQL Server： BEGIN TRANSACTION / COMMIT TRANSACTION
    +  MySQL / MariaDB : START TRANSACTION ……
    +  Oracle ： SET TRANSACTION
    +  PostgreSQL : BEGIN
+  保留点：部分提交或回退；

## 21. 游标

+  定义：一个存储在 DBMS 服务器上的数据库查询，不是一条 SELECT 语句，而是被该语句检索出的结果集；
+  使用游标后，可根据需要滚动或浏览其中的数据；
+  特性：
    +  标记游标只读，使数据能读取但不能更新和删除；
    +  能控制可执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）；
    +  标记某些列为可编辑的，某些列为不可编辑的；
    +  规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问；
    +  指示 DBMS 对检索处的数据（而不是值出表中活动数据）进行复制，是数据在游标打开和访问期间不变化；
+  使用游标：
    +  使用步骤：
        +  在使用游标前，必须声明定义；
        +  游标一旦声明，就必须打开游标以供使用；
        +  对填有数据的游标，根据需要取出各行；
        +  结束使用游标时需关闭游标；可能的话释放游标；
    +  创建游标：DECLARE 命名游标 定义相应的 SELECT 语句；
    +  使用游标：OPEN 命名游标
    +  访问游标数据：FETCH
    +  关闭游标：CLOSE（游标一旦关闭，如果不再打开，就不能使用）

## 22.  高级 SQL 特性

+  约束：管理如何插入或处理数据库数据的规则；
    +  关系数据库存储分解多个表的数据，每个表存储相应的数据；利用**键**来建立一个表到另一个表的引用；
    +  主键：一种特殊的约束，用来保证一列中的值是唯一的，且永不改动；唯一标识表中的每一行；
        +  特点：
            +  任意两行的主键值不相同；
            +  每行都具有一个主键值（不允许NULL值）；
            +  包含主键值的列从不修改或更新；
            +  主键值不能重用；
    +  外键：表中的一列，其值必须列在另一个表的主键中；（外键有助防止意外删除）
    +  唯一约束：保证一列中的数据是唯一的；
        +  与主键的区别：
            +  表可包含多个唯一约束，但每个表只允许一个主键；
            +  唯一约束列可以包含NULL 值；
            +  唯一约束列可修改或更新；
            +  唯一约束列的值可以重复使用；
            +  与主键不一样，唯一约束不能用来定义外键；
        +  唯一约束可用 UNIQUE 关键字在表定义中定义；也可以用单独的 CONSTRAINT 定义；
    +  检查约束：保证一列（或一组列）中的数据满足一组指定的条件；
        +  检查最小或最大值；
        +  指定范围；
        +  只允许特定的值；
+  索引：用来排序数据以加快搜索和排序操作的速度；
    +  注意事项：
        +  索引改善检索操作的性能，但降低了数据插入、修改和删除的性能；在执行这增改删这些操作时，DBMS 必须动态地更新索引；
        +  索引数据可能要占用大量的存储空间；
        +  并非所有数据都适合做索引；
        +  索引用于数据过滤和数据排序；
        +  可以在索引中定义多个列；
    +  创建索引：CREATE INDEX 索引名 ON 表明(列表名)
    +  索引必须唯一命名；
+  触发器：特殊的存储过程，在特定的数据库活动发生是自动执行；
    +  与存储过程的区别：存储过程只是简单的存储 SQL 语句；触发器与单个的表相关联；
    +  触发器内的代码具有以下数据的访问权：
        +  INSERT 操作中的所有新数据；
        +  UPDATE 操作中的所有新数据和旧数据；
        +  DELETE 操作中删除的数据；
    +  触发器一般的用途：
        +  保证数据一致；
        +  基于某个表的变动在其他表上执行活动；
        +  进行额外的验证并根据需要回退数据；
        +  计算计算列的值或更新时间戳；
+  数据库安全：
    +  任何完全系统的基础都是用户授权和身份确认；
    +  需要保护的操作：
        +  对数据库管理功能（创建表、更改或删除已存在的表等）的访问；
        +  对特定数据库或表的访问；
        +  访问的类型（只读、对特定的列的访问等）；
        +  仅通过视图或存储过程对表进行访问；
        +  创建多层次的安全措施，从而允许多种基于登录的访问和控制；
        +  限制管理用户账户的能力；