# Redis 深度历险核心原理与应用实践

## 第三篇：集群篇

### 3.1 主从同步

+ 集群的优点：
    + 保障系统数据安全；
    + 主节点 Master 挂掉时，从节点 Slave 接管，可继续服务；（否则主节点需要经过重启和数据恢复，耗时影响线上业务）
+ CAP 原理：
    + 现代分布式系统理论基石；
    + CAP：
        + C：Consistent，一致性；
        + A：Availability，可用性；
        + P：Partition tolerance，分区容忍性；
    + 网络分区：
        + 背景：分布式系统节点往往分布在不同的机器上进行网络隔开；
        + “网络分区”指网络断开的场景；
        + 若发生“网络分区”，“一致性”和“可用性”两难全；
+ 主从同步：
    + Redis 的主从数据是**异步同步**；（并不满足一致性，但满足**最终一致性**）
    + 客户端连接主节点修改数据后，立即返回；即使主从网络断开下，主节点依旧可对外正常服务；（满足可用性）
    + 最终一致性：只要主从节点连上，从节点积极追赶主节点，最终与主节点状态保持一致；
+ 从从同步：从从同步可减轻主节点同步的负担；
+ 增量同步：
    + **同步指令流**（对状态产生修改的指令）；
    + 主节点：将存储在本地内存 buffer 中的指令**异步**同步至从节点；
    + 从节点：一边同步指令，一边反馈偏移量；
    + 本地内存 buffer：
        + 容量有限，类似一个定长的环形数组；
        + 若数组容量满了，则从头开始覆盖前面内容；
        + 若因长时间没有同步，主节点的同步指令可能被覆盖掉，这时需更加复杂的同步机制 —— 快照同步；
+ 快照同步：
    + 同步快照；一个非常消耗资源的操作；
    + 主节点：bgsave，创建当前快照；再将快照文件的内容发送至从节点；
    + 从节点：接收快照文件，存储至硬盘中；清空当前内存中的数据；执行一次全量加载；加载后执行增量加载；
    + 问题：若**快照同步时间过长**或**复制 buffer 容量过小**，导致同步期间增量指令被覆盖，需再次发起快照同步，陷入死循环；（需配置合适的复制 buffer 大小）
+ 增加从节点：先执行快照同步，完成后再增量同步；
+ 无盘复制：
    + 主节点直接通过套接字将快照内容发送至从节点；
    + 主节点：一边遍历内存数据，一边将序列化的内容发送至从节点；
    + 优点：免去磁盘文件 IO 操作；   
+ wait 指令：
    + Redis 3.0 后推出；
    + wait 指令可让异步复制变成同步复制，确保强一致性（不严格）；
    + wait 指令两个参数：
        + 节点的数量 N；
        + 时间 t：毫秒为单位；
        + 意义：wait 指令之前所有写操作同步到 N 个从节点，最多等待时间 t；（确保 N 个从节点的同步没有滞后）
        + 若 t = 0，表示无限等待直到 N 个从节点同步完成；若出现网络分区，主从同步无法继续进行，wait 指令永远阻塞，Redis 丧失可用性；

### [3.2 Sentinel]()

### [3.3 Codis]()

### [3.4 Cluster]()