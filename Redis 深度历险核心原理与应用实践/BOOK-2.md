# Redis 深度历险核心原理与应用实践

## 第二篇：原理篇

### 2.1 线程 IO 模型

+ Redis 单线程程序；所有数据存储内存中，运算都是内存级别的；注意不要运行时间复杂度 O(n) 级别的指令，可能造成卡顿；
+ 阻塞IO：套接字 Socket 连接和读写默认是阻塞的；
+ 非阻塞IO：打开 Non_Blocking 选项，读写方法不阻塞；
+ 事件轮询（多路复用）：
    + Java 中的 NIO 技术；
    + 解决问题：非阻塞 IO 未读完和未写完的问题；
    + 实现 API：select 函数、epoll 函数等；
        + 区别：select 不管是否有数据传输均轮询；epoll 仅轮询有数据传输的；
        + select 提供 timeout 参数，若无任何事件，线程最多阻塞等待 timeout，过时立即返回；
        + select 缺点：若连接数量过多，所有连接每个周期均需轮询，造成单个连接等待的时间过长；
+ 指令队列：客户端发过来的指令，先来先服务；
+ 响应队列：将指令返回的结果回复给客户端；
+ 定时任务：
    + 若线程阻塞在 select 的调用上，那么定时任务将无法准时调用；
    + 解决：定时任务记录在“最小堆”的数据结构中，快到期的任务排在堆上方；每个周期里，Redis 会处理到时间点的任务，处理完毕后记录快到期的任务还需等待的时间（timeout 参数）；

### [2.2 通信协议]()

### [2.3 持久化]()

### [2.4 管道]()

### [2.5 事务]()

### [2.6 PubSub]()

### [2.7 小对象压缩]()