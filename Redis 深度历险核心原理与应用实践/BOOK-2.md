# Redis 深度历险核心原理与应用实践

## 第二篇：原理篇

### 2.1 线程 IO 模型

+ Redis 单线程程序；所有数据存储内存中，运算都是内存级别的；注意不要运行时间复杂度 O(n) 级别的指令，可能造成卡顿；
+ 阻塞IO：套接字 Socket 连接和读写默认是阻塞的；
+ 非阻塞IO：打开 Non_Blocking 选项，读写方法不阻塞；
+ 事件轮询（多路复用）：
    + Java 中的 NIO 技术；
    + 解决问题：非阻塞 IO 未读完和未写完的问题；
    + 实现 API：select 函数、epoll 函数等；
        + 区别：select 不管是否有数据传输均轮询；epoll 仅轮询有数据传输的；
        + select 提供 timeout 参数，若无任何事件，线程最多阻塞等待 timeout，过时立即返回；
        + select 缺点：若连接数量过多，所有连接每个周期均需轮询，造成单个连接等待的时间过长；
+ 指令队列：客户端发过来的指令，先来先服务；
+ 响应队列：将指令返回的结果回复给客户端；
+ 定时任务：
    + 若线程阻塞在 select 的调用上，那么定时任务将无法准时调用；
    + 解决：定时任务记录在“最小堆”的数据结构中，快到期的任务排在堆上方；每个周期里，Redis 会处理到时间点的任务，处理完毕后记录快到期的任务还需等待的时间（timeout 参数）；

### 2.2 通信协议

+ RESP：Redis 序列化协议（Redis Serialization Protocol）；直观的文本协议，优势实现过程简单解析性能好；
+ 五种最小单元类型：（单元结束时统一加回车换行：\r\n）
    + 单行字符串：“+” 开头
    + 多行字符串：“$” 开头，后接字符串长度
    + 整数值：“:” 开头，后接整数的字符串形式
    + 错误消息：“-” 开头
    + 数组：“*” 开头

```shell script
# 单行字符串 “hello world”
+hello world\r\n

# 多行字符串 “hello world”（也可表现成单行字符串）
$11\r\nhello world\r\n

# 整数 “1024”
:1024\r\n

# 错误
-WRONGTYPE\r\n

# 数组 [1,2,3]
*3\r\n:1\r\n:2\r\n:3\r\n

# NULL
$-1\r\n

# 空串
$0\r\n\r\n
```

### 2.3 持久化

+ Redis 持久化机制：
    + 快照：全量备份；内存数据的二进制序列化形式；
    + AOF 日志：连续增量备份；内存数据修改的指令记录文本；定期需重写；
+ 快照原理：
    + Redis 单线程，线程同时负责多个客户端 Socket 的并发读写操作和内存数据结构的逻辑读写；
    + 内存快照需进行文件 IO 操作，且不能使用多路复用 API（会拖累服务器性能）；
    + 为不阻塞线上业务，Redis 需**一边持久化一边响应**客户端请求；
    + Redis 快照持久化机制：使用操作系统的**多线程 COW（Copy on write）实现**；
+ fork 多线程
    + Redis 持久化会调用 glibc 的函数 fork 产生一个子进程；持久化由子进程处理，父进程继续处理客户端请求；
    + 初期：父子进程共用内存中代码段和数据段；（内存几乎没有明显变化）
    + 接着：子进程做持久化，对内存数据仅遍历读取，不修改；父进程可能会不间断修改；————> COW 机制：数据段页面分离；
    + 若父进程要修改数据，该页面会被复制一份分离出来，然后对复制的页面进行修改；（内存增加）
    + 内存不会超过原来的两倍；又因 Redis 实例里冷数据普遍占比高，实际被分离的页面占少部分；
+ AOF 原理：
    + AOF 日志：存储 Redis 服务器顺序指令序列；只记录**修改**指令；
    + 记录逻辑：**先执行，后存储**；
    + Redis 长期运行，AOF 日志越来越长；日志过长影响 Redis 重启重放 AOF 日志耗时过长，导致长时间无法提供服务；过长需重写；
    + 重写：bgrewriteaof 指令，原理是开辟子进程对内存进行遍历，转换成一系列 Redis 操作指令，再序列化到新的 AOF 日志文件中；最后追加操作期间的发生的增量 AOF 日志，完成后替换；
+ fsync：
    + 对 AOF 文件的写操作：实际上将内容写到内核为文件描述符分配的一个**内存缓存**中，然后再由内核异步将脏数据刷回磁盘；
    + 手动刷回：Linux 中 glibc 中的 fsync(int fd) 函数；可将指定内容强制从内存刷到磁盘中；
    + Redis 两种刷回策略：
        + 周期性刷回：每隔一段时间刷回；（数据安全性和性能之间的折中）
        + 一个指令刷回一次：操作耗时，磁盘 IO 耗时；
        + 由操作系统配置：不安全，若机器突然宕机，AOF 日志内容可能没有刷回磁盘中；
+ 运维：
    + 快照是开启子进程的方式进行，需遍历整个内存，大块写磁盘；
    + AOF 的 fsync 是一个耗时 IO 操作，降低 Redis 性能和增加系统 IO 负担；
    + Redis **主节点**不进行持久化操作；持久化操作在**从节点**进行；
    + 在网络分区中，注意主从节点网络的畅通，做好实时监控工作，以免从节点长时间连不上主节点，造成数据丢失；
+ Redis 4.0 混合持久化：
    + 快照：很少用于恢复内存状态，因会丢失大量数据；
    + AOF 重放：通常使用；但 AOF 重放比快照慢，若数据量大启动花费较长时间；
    + 混合持久化：Redis 4.0 推出；快照 + 少量 AOF（持久化开始到结束这段时间的增量 AOF 日志）；Redis 重启后先加载“快照”，再重放 AOF；效率大幅提升；

### [2.4 管道]()

### [2.5 事务]()

### [2.6 PubSub]()

### [2.7 小对象压缩]()